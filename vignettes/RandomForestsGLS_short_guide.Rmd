---
title: "How to use RandomForestsGLS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use RandomForestsGLS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

We will start by loading the `RandomForestsGLS` R package. This package fits non-linear regression models on dependent data with Generalised Least Square (GLS) based Random Forest (RF-GLS) detailed in Saha, Basu and Datta (2020) https://arxiv.org/abs/2007.15421. We start by loading the package,

```{r setup}
library(RandomForestsGLS)
```

Next, we discuss how can we use the RandomForestsGLS package for estimation and prediction in a non-linear regression setup under correlated errors in different scenarios.

##  1. Spatial data with known covariance parameters

First, we will consider the case, where we have a spatial point referenced data with and the working covariance matrix corresponds to Gaussian process with matern covariance fucntion with known parameters. In order to fit the model, the code requires: 

+ Coordinates ('coords'): an $n \times 2$ matrix of 2-dimensional locations.
+ Response ('y'):  an $n$ length vector of response at the observed coordinates.
+ Covariates ('X'): an $n \times p$ matrix of the covariates in the observation coordinates.
+ Covariates for estimation ('Xest'): an $ntest \times p$ matrix of the covariates where we want to estimate the function. Must have identical variables as that of 'X'. Default is 'X'.
+ The parameters corresponding to the covariance function

For the details on choice of other parameters, please refer to the help file of the code 'RFGLS_estimate_spatial', which can be acessed with '?RFGLS_estimate_spatial'. 

### Simulation

Next we simulate a data from the following model:
$$
y = 10\sin(\pi x) + w+ \epsilon; \:\: \epsilon \sim N(\mathbf{0},\: \tau^2 \mathbf{I}), \tau^2 = 0.1; \:\:\: w \sim \textit{exponential GP};\: \sigma^2 = 10; \phi = 5.
$$
Here, $E(Y) = 10\sin(\pi X)$; $w$ accounts for the spatial correlation, which is modelled by a exponential Gaussian process with spatial variance $\sigma^2 = 10$ and spatial correlation decay $\phi = 5$; and $\epsilon$ is the i.i.d white noise with variance $\tau^2$, which is also called the nugget in spatial literature.

For convenience, we wil only simulate with $n = 200$

```{r simulation}
rmvn <- function(n, mu = 0, V = matrix(1)){
  p <- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension not right!")
  D <- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n <- 200
coords <- cbind(runif(n,0,1), runif(n,0,1))
set.seed(2)
x <- as.matrix(rnorm(n),n,1)
sigma.sq = 1
phi = 5
tau.sq = 0.1
D <- as.matrix(dist(coords))
R <- exp(-phi*D)
w <- rmvn(1, rep(0,n), sigma.sq*R)
y <- rnorm(n, 10*sin(pi * x) + w, sqrt(tau.sq))
```

### Model Fitting

Next, we fit the GLS based random forest on the simulated data. For spatial data, this combines the advantages of random forest and gaussian Process using Nearest Neighbor Gaussian Process in fitting the RF-GLS. Here we only build 10 regression trees with 'ntree = 10' for convenience, but we suggest to use higher values of 'ntree'. As far as choice of covariance models are concerned, the codes for covariance models other than exponential model are in beta testing stage. Hence we strongly recommend the users to use the exponential model ($\nu = 0.5$ in matern covariance model).

```{r model_fit}
estimation_result <- RFGLS_estimate_spatial(coords, y, x, ntree = 10, sigma.sq = sigma.sq, tau.sq = tau.sq, phi = phi)
```

The estimate of the function at the covarates 'Xtest' is given in 'estimation_reult$predicted'. For interpretation of the rest of the outputs, please see the help file of the code 'RFGLS_estimate_spatial'. One can also take the advantage of parallelization, contingent upon the availability of multiple cores. The component 'h' in estimation_result determines the number of cores to be used. For example we can obtain identical results using 'h = 4' cores. For very small dataset ('n') and small number of trees ('ntree'), setting up the parallelization takes significant amount of time (compared to that of actually fitting the model without parallelization), hence it is recommended to parallelize moderately high 'n' and/or 'ntree' (here we show parallelization for 'n = 200', 'ntree = 10', but in practice we recomend to parallelize for higher values of 'n' and/or 'ntree'). It is strongly recommended that the max value of 'h' is kept strictly less than the number of total cores available. 

```{r model_fit_parallel}
estimation_result_parallel <- RFGLS_estimate_spatial(coords, y, x, ntree = 10, h = 4, sigma.sq = sigma.sq, tau.sq = tau.sq, phi = phi)
```

### Estimation

Given a fitted model using 'RFGLS_estimate_spatial', we can estimate the function at new covariate values as follows:

```{r model_estimate}
Xtest <- matrix(seq(0,1, by = 1/1000), 1001, 1)
RFGLS_predict <- RFGLS_predict(estimation_result, Xtest)
```

Here too, we can parallelize, but the estimation procedure is very fast by default without parallelization. Hence, unless we are dealing with very high values of 'n' and 'ntree', we do not recommed to parallelize here. 

### Prediction

Given a fitted model using 'RFGLS_estimate_spatial', we can predict the response/outcome at new locations provided the covariates at that location. This approach performs krigging at a new location using the function estimates at the corresponding covariate values. Here we use divide the simulated data into training and test sets in 4:1 ratios. Next we perform prediction on the test set using a model fitted on the trining set.

```{r prediction}
estimation_result <- RFGLS_estimate_spatial(coords[1:160,], y[1:160], matrix(x[1:160,],160,1), ntree = 10, sigma.sq = sigma.sq, tau.sq = tau.sq, phi = phi)
prediction_result <- RFGLS_predict_spatial(estimation_result, coords[1:160,], coords[161:200,], matrix(x[161:200,],40,1))
```

##  2. Spatial data with unknown covariance parameters
If the model parameters are not known, prior to RF-GLS model fitting, the model parameters are estimated internally from the residuals obtained after fitting a classical random forest model on the training data. The 'RFGLS_estimate_spatial' code takes care of that for us if we set 'param_estimate = TRUE' and provide the covariance model of choice. Here too, we strongly recommend using the exponential model. 
```{r model_fit_unknown}
estimation_result <- RFGLS_estimate_spatial(coords, y, x, ntree = 10, param_estimate = TRUE)
```

The estimation and prediction in this scenario is identical to that of the scenario, where the parameter values are known.

## 3. Temporal data with known parameters
In case of temporal data, RF-GLS uses the auto-regressive (AR) covariance structure to account for the correlated errors. In case of known parameters, to fit the model, the code requires: 

+ Response ('y'):  an $n$ length vector of response at the observed time points.
+ Covariates ('X'): an $n \times p$ matrix of the covariates in the observation time points.
+ Covariates for estimation ('Xest'): an $ntest \times p$ matrix of the covariates where we want to estimate the function. Must have identical variables as that of 'X'. Default is 'X'.
+ The parameters corresponding to the AR process.

For the details on choice of other parameters, please refer to the help file of the code 'RFGLS_estimate_timeseries', which can be acessed with '?RFGLS_estimate_timeseries'. 

### Simulation

Next we simulate a data from the following model:
$$
y = 10\sin(\pi x) + \mathbf{e}; e_t = \rho e_{t-1} + \eta_t; \eta_t \sim N(0,\sigma^2); e_1 = \eta_1.
$$

Here, $E(Y) = 10\sin(\pi X)$; $\mathbf{e}$ which is an AR(1) process, accounts for the temporal correlation, $\sigma^2$ denotes the variance of white noise part of the AR(1) process.

For convenience, we wil only simulate with $n = 200$

```{r simulation_temporal}
rho <- 0.5
set.seed(1)
b <- rho
s <- sqrt(sigma.sq)
eps = arima.sim(list(order = c(1,0,0), ar = b), n = n, rand.gen = rnorm, sd = s)
y <- eps + 10*sin(pi * x)
```

### Model Fitting

Next, we fit the GLS based random forest on the simulated data. For temporal data with known coefficients, we proceed as follows. As mentioned earlier, here we only build 10 regression trees with 'ntree = 10' for convenience, but we suggest to use higher values of 'ntree'.

```{r model_fit_temporal}
estimation_result <- RFGLS_estimate_timeseries(y, x, ntree = 10, lag_params = rho)
```

This can similarly be parallelized as that of spatial data as discussed before, by chnging the value of 'h'. It is strongly recommended that the max value of 'h' is kept strictly less than the number of total cores available. 

### Estimation

Given a fitted model using 'RFGLS_estimate_timeseries', we can estimate the function at new covariate values as follows:

```{r model_estimate_temporal}
Xtest <- matrix(seq(0,1, by = 1/1000), 1001, 1)
RFGLS_predict <- RFGLS_predict(estimation_result, Xtest)
```

The estimation code is identical to that corresponding to the spatial data. 

## 4. Temporal data with unknown parameters

If the model parameters are not known, prior to RF-GLS model fitting, the model parameters are estimated internally from the residuals obtained after fitting a classical random forest model on the training data. The 'RFGLS_estimate_timeseries' code takes care of that for us if we set 'param_estimate = TRUE'. It will estimate the parameters by fitting a AR(p) process, where 'p' is the length of the input 'lag_params'. Hence if we want to estimate the parameters from a AR(p) process, 'lag_params' should be any vector of length 'p'. Here we work with 'p = 1'.

```{r model_fit_unknown_temporal}
estimation_result <- RFGLS_estimate_timeseries(y, x, ntree = 10, lag_params = c(0))
```

The estimation in this scenario is identical to that of the scenario, where the parameter values are known.
